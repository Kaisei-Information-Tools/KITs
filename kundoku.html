---
layout: default_new
title: 訓読文エディタ
css: kundoku
old_base_css: true
---

<h1>訓読文エディタ</h1>
<div class="editor">
  <div class="input-area">
    <textarea id="kanbunInput" rows="10" cols="30" placeholder="ここに漢文を入力"></textarea>
    <br />
    <button onclick="renderPreview()">プレビュー更新</button>
    <button onclick="rearrangeByKaeriten()">返り点に従って並べ替え</button>
    <button onclick="restoreOriginal()">元に戻す</button>
    <p>返り点や送り仮名をつけたい文字をクリックすることで入力できます</p>
  </div>
  <div class="preview-area" id="preview"></div>
</div>
<script>
  // 元の状態を保存する変数
  let originalPreviewState = null;
  
  // プレビュー生成関数
  function renderPreview() {
    const inputText = document.getElementById("kanbunInput").value;
    const preview = document.getElementById("preview");
    preview.innerHTML = "";

    const lines = inputText.split("\n");
    lines.forEach((line) => {
      const p = document.createElement("p");
      for (let i = 0; i < line.length; i++) {
        const container = document.createElement("span");
        container.className = "char-container";

        // メインの漢字表示用
        const charSpan = document.createElement("span");
        charSpan.className = "char";
        charSpan.textContent = line[i];
        if (line[i] === "-") {
          charSpan.textContent = "―";
          charSpan.style.transform = "scaleY(0.3)";
          charSpan.style.display = "inline-block";
          charSpan.style.margin = "-12px 0";
        }
        container.appendChild(charSpan);

        // 返り点用スパン（初期は空）
        const kaeritenSpan = document.createElement("span");
        kaeritenSpan.className = "kaeriten";
        kaeritenSpan.textContent = "";
        container.appendChild(kaeritenSpan);

        // 送り仮名用スパン（初期は空）
        const okuriganaSpan = document.createElement("span");
        okuriganaSpan.className = "okurigana";
        okuriganaSpan.textContent = "";
        container.appendChild(okuriganaSpan);

        // クリックで注釈編集
        container.addEventListener("click", function (e) {
          annotateCharacter(container);
          e.stopPropagation();
        });

        p.appendChild(container);
      }
      preview.appendChild(p);
    });
  }

  // 注釈編集関数
  function annotateCharacter(container) {
    const Kaeriten = container.querySelector(".kaeriten");
    const currentKaeriten = Kaeriten.textContent;
    const currentOkurigana = container.querySelector(".okurigana").textContent;

    const newKaeriten = prompt(
      "返り点を入力してください（現在: " + currentKaeriten + "）",
      currentKaeriten,
    );
    const newOkurigana = prompt(
      "送り仮名を入力してください（現在: " + currentOkurigana + "）",
      currentOkurigana,
    );

    Kaeriten.textContent = newKaeriten || "";
    if (newKaeriten === "一レ") {
      Kaeriten.style.letterSpacing = "-11px";
      Kaeriten.style.transform = "translate(-45%, 30%)";
    } else if (newKaeriten === "上レ") {
      Kaeriten.style.letterSpacing = "-5px";
      Kaeriten.style.transform = "translate(-45%, 70%) scaleY(0.8)";
    } else {
      Kaeriten.style.transform = "translate(-45%, 50%)";
    }
    if (container.querySelector(".char").textContent === "―") {
      Kaeriten.style.transform = "translate(-45%, 50%)";
    }
    container.querySelector(".okurigana").textContent = newOkurigana || "";
  }

  // 返り点に従って並べ替える関数
  function rearrangeByKaeriten() {
    const preview = document.getElementById("preview");
    const paragraphs = preview.querySelectorAll("p");
    
    // 元の状態を保存
    if (!originalPreviewState) {
      originalPreviewState = preview.cloneNode(true);
    }
    
    paragraphs.forEach((p) => {
      const containers = Array.from(p.querySelectorAll(".char-container"));
      if (containers.length === 0) return;
      
      // 各文字の情報を抽出
      const chars = containers.map((container, index) => ({
        index: index,
        char: container.querySelector(".char").textContent,
        kaeriten: container.querySelector(".kaeriten").textContent,
        okurigana: container.querySelector(".okurigana").textContent,
        container: container
      }));
      
      // 返り点に基づいて読み順を計算
      const readingOrder = calculateReadingOrder(chars);
      
      // 並べ替えた結果を表示
      p.innerHTML = "";
      readingOrder.forEach(index => {
        const char = chars[index];
        // 文字を追加
        const span = document.createElement("span");
        span.textContent = char.char;
        span.className = "rearranged-char";
        p.appendChild(span);
        
        // 送り仮名を追加
        if (char.okurigana) {
          const okuriganaSpan = document.createElement("span");
          okuriganaSpan.textContent = char.okurigana;
          okuriganaSpan.className = "rearranged-okurigana";
          p.appendChild(okuriganaSpan);
        }
      });
    });
  }
  
  // 元に戻す関数
  function restoreOriginal() {
    if (originalPreviewState) {
      const preview = document.getElementById("preview");
      preview.innerHTML = originalPreviewState.innerHTML;
      
      // イベントリスナーを再設定
      const containers = preview.querySelectorAll(".char-container");
      containers.forEach((container) => {
        container.addEventListener("click", function (e) {
          annotateCharacter(container);
          e.stopPropagation();
        });
      });
    }
  }
  
  // 返り点を解析する関数
  function parseKaeriten(kaeritenStr) {
    if (!kaeritenStr) return null;
    
    // 複合パターンの解析: 一レ、二レ、上レなど
    const compoundMatch = kaeritenStr.match(/^([一二三四五六七八九十上中下天地人甲乙丙丁])(レ|㆑)$/);
    if (compoundMatch) {
      return { type: 'compound', main: compoundMatch[1], hasRe: true };
    }
    
    // レ点
    if (kaeritenStr === 'レ' || kaeritenStr === '㆑') {
      return { type: 're' };
    }
    
    // 一二三点
    const numMap = { '一': 1, '二': 2, '三': 3, '四': 4, '五': 5, '六': 6, '七': 7, '八': 8, '九': 9, '十': 10 };
    if (numMap[kaeritenStr]) {
      return { type: 'number', value: numMap[kaeritenStr], str: kaeritenStr };
    }
    
    // 上中下点
    const posMap = { '上': 3, '中': 2, '下': 1 };
    if (posMap[kaeritenStr]) {
      return { type: 'position', value: posMap[kaeritenStr], str: kaeritenStr };
    }
    
    // 天地人点
    const skyMap = { '天': 3, '地': 2, '人': 1 };
    if (skyMap[kaeritenStr]) {
      return { type: 'sky', value: skyMap[kaeritenStr], str: kaeritenStr };
    }
    
    // 甲乙丙丁点
    const kanMap = { '甲': 1, '乙': 2, '丙': 3, '丁': 4 };
    if (kanMap[kaeritenStr]) {
      return { type: 'kan', value: kanMap[kaeritenStr], str: kaeritenStr };
    }
    
    return null;
  }
  
  // 返り点から読み順を計算する関数
  function calculateReadingOrder(chars) {
    const order = [];
    const processed = new Set();
    
    // 各文字の返り点を解析
    const parsedChars = chars.map((char, index) => ({
      ...char,
      index: index,
      parsed: parseKaeriten(char.kaeriten)
    }));
    
    function processRange(start, end) {
      let i = start;
      
      while (i < end) {
        if (processed.has(i)) {
          i++;
          continue;
        }
        
        const char = parsedChars[i];
        const parsed = char.parsed;
        
        // 返り点がない場合
        if (!parsed) {
          order.push(i);
          processed.add(i);
          i++;
          continue;
        }
        
        // レ点: 次の1文字を先に読む
        if (parsed.type === 're') {
          if (i + 1 < end && !processed.has(i + 1)) {
            order.push(i + 1);
            processed.add(i + 1);
          }
          order.push(i);
          processed.add(i);
          i++;
          continue;
        }
        
        // 数字点の処理
        if (parsed.type === 'number') {
          const group = collectNumberGroup(i, end);
          if (group.length > 1) {
            processNumberGroup(group, end);
            i = group[group.length - 1] + 1;
          } else {
            order.push(i);
            processed.add(i);
            i++;
          }
          continue;
        }
        
        // 上中下点の処理
        if (parsed.type === 'position') {
          const group = collectPositionGroup(i, end);
          if (group.length > 1) {
            processPositionGroup(group, end);
            i = group[group.length - 1] + 1;
          } else {
            order.push(i);
            processed.add(i);
            i++;
          }
          continue;
        }
        
        // 天地人点の処理
        if (parsed.type === 'sky') {
          const group = collectSkyGroup(i, end);
          if (group.length > 1) {
            processSkyGroup(group, end);
            i = group[group.length - 1] + 1;
          } else {
            order.push(i);
            processed.add(i);
            i++;
          }
          continue;
        }
        
        // 甲乙丙丁点の処理
        if (parsed.type === 'kan') {
          const group = collectKanGroup(i, end);
          if (group.length > 1) {
            processKanGroup(group, end);
            i = group[group.length - 1] + 1;
          } else {
            order.push(i);
            processed.add(i);
            i++;
          }
          continue;
        }
        
        // 複合パターンの処理
        if (parsed.type === 'compound') {
          const mainParsed = parseKaeriten(parsed.main);
          if (mainParsed) {
            if (mainParsed.type === 'number') {
              const group = collectNumberGroup(i, end);
              if (group.length > 1) {
                processNumberGroupWithRe(group, end);
                i = group[group.length - 1] + 1;
              } else {
                // レとして処理
                if (i + 1 < end && !processed.has(i + 1)) {
                  order.push(i + 1);
                  processed.add(i + 1);
                }
                order.push(i);
                processed.add(i);
                i++;
              }
            } else if (mainParsed.type === 'position') {
              const group = collectPositionGroup(i, end);
              if (group.length > 1) {
                processPositionGroupWithRe(group, end);
                i = group[group.length - 1] + 1;
              } else {
                // レとして処理
                if (i + 1 < end && !processed.has(i + 1)) {
                  order.push(i + 1);
                  processed.add(i + 1);
                }
                order.push(i);
                processed.add(i);
                i++;
              }
            }
          }
          continue;
        }
        
        order.push(i);
        processed.add(i);
        i++;
      }
    }
    
    // 数字グループを収集
    function collectNumberGroup(startIdx, endIdx) {
      const group = [startIdx];
      const startValue = parsedChars[startIdx].parsed.value;
      
      for (let j = startIdx + 1; j < endIdx; j++) {
        const p = parsedChars[j].parsed;
        if (!p) continue;
        
        let checkValue = 0;
        if (p.type === 'number') {
          checkValue = p.value;
        } else if (p.type === 'compound') {
          const mainP = parseKaeriten(p.main);
          if (mainP && mainP.type === 'number') {
            checkValue = mainP.value;
          }
        }
        
        if (checkValue > 0 && checkValue < startValue) {
          group.push(j);
          if (checkValue === 1) break;
        }
      }
      
      return group;
    }
    
    // 上中下グループを収集
    function collectPositionGroup(startIdx, endIdx) {
      const group = [startIdx];
      const startValue = parsedChars[startIdx].parsed.value;
      let maxFound = startValue;
      
      for (let j = startIdx + 1; j < endIdx; j++) {
        const p = parsedChars[j].parsed;
        if (!p) continue;
        
        let checkValue = 0;
        if (p.type === 'position') {
          checkValue = p.value;
        } else if (p.type === 'compound') {
          const mainP = parseKaeriten(p.main);
          if (mainP && mainP.type === 'position') {
            checkValue = mainP.value;
          }
        }
        
        if (checkValue > startValue) {
          group.push(j);
          maxFound = Math.max(maxFound, checkValue);
          if (checkValue === 3) break;  // 上（最大値）
        }
      }
      
      return group;
    }
    
    // 天地人グループを収集
    function collectSkyGroup(startIdx, endIdx) {
      const group = [startIdx];
      const startValue = parsedChars[startIdx].parsed.value;
      
      for (let j = startIdx + 1; j < endIdx; j++) {
        const p = parsedChars[j].parsed;
        if (!p) continue;
        
        let checkValue = 0;
        if (p.type === 'sky') {
          checkValue = p.value;
        } else if (p.type === 'compound') {
          const mainP = parseKaeriten(p.main);
          if (mainP && mainP.type === 'sky') {
            checkValue = mainP.value;
          }
        }
        
        if (checkValue > startValue) {
          group.push(j);
          if (checkValue === 3) break;  // 天（最大値）
        }
      }
      
      return group;
    }
    
    // 甲乙丙丁グループを収集
    function collectKanGroup(startIdx, endIdx) {
      const group = [startIdx];
      const startValue = parsedChars[startIdx].parsed.value;
      
      for (let j = startIdx + 1; j < endIdx; j++) {
        const p = parsedChars[j].parsed;
        if (p && p.type === 'kan' && p.value > startValue) {
          group.push(j);
          if (p.value === 4) break;  // 丁（最大値）
        }
      }
      
      return group;
    }
    
    // 数字グループを処理（一二三の順で読む）
    function processNumberGroup(group, endIdx) {
      // 値でソート（小さい順 = 一、二、三）
      const sorted = group.map(idx => ({
        idx: idx,
        value: parsedChars[idx].parsed.type === 'compound' 
          ? parseKaeriten(parsedChars[idx].parsed.main).value 
          : parsedChars[idx].parsed.value
      })).sort((a, b) => a.value - b.value);
      
      // 最初の返り点の後ろから処理開始
      const firstIdx = group[0];
      const lastReturnIdx = sorted[sorted.length - 1].idx;
      
      // 最後の返り点より後ろの文字を先に読む
      // 返り点がない文字、またはレ点のみを読み進める
      for (let j = lastReturnIdx + 1; j < endIdx; j++) {
        if (!processed.has(j) && !group.includes(j)) {
          const p = parsedChars[j].parsed;
          // 返り点がない文字、またはレ点のみ処理（他の返り点グループは別途処理）
          if (!p || p.type === 're') {
            order.push(j);
            processed.add(j);
          } else {
            break;
          }
        }
      }
      
      // 返り点を順に処理
      for (const item of sorted) {
        if (!processed.has(item.idx)) {
          order.push(item.idx);
          processed.add(item.idx);
        }
      }
      
      // 間の文字を処理
      for (let j = firstIdx; j <= lastReturnIdx; j++) {
        if (!processed.has(j)) {
          order.push(j);
          processed.add(j);
        }
      }
    }
    
    // 数字グループをレ付きで処理
    function processNumberGroupWithRe(group, endIdx) {
      const sorted = group.map(idx => ({
        idx: idx,
        value: parsedChars[idx].parsed.type === 'compound' 
          ? parseKaeriten(parsedChars[idx].parsed.main).value 
          : parsedChars[idx].parsed.value,
        hasRe: parsedChars[idx].parsed.type === 'compound'
      })).sort((a, b) => a.value - b.value);
      
      for (const item of sorted) {
        if (item.hasRe && item.idx + 1 < endIdx && !processed.has(item.idx + 1)) {
          order.push(item.idx + 1);
          processed.add(item.idx + 1);
        }
        if (!processed.has(item.idx)) {
          order.push(item.idx);
          processed.add(item.idx);
        }
      }
    }
    
    // 上中下グループを処理（上→中→下の順で読む）
    function processPositionGroup(group, endIdx) {
      const sorted = group.map(idx => ({
        idx: idx,
        value: parsedChars[idx].parsed.type === 'compound' 
          ? parseKaeriten(parsedChars[idx].parsed.main).value 
          : parsedChars[idx].parsed.value,
        hasRe: parsedChars[idx].parsed.type === 'compound'
      })).sort((a, b) => b.value - a.value);  // 降順（上→中→下）
      
      // 上→中→下の順で処理
      for (let k = 0; k < sorted.length; k++) {
        const currentMark = sorted[k];
        const nextMark = k + 1 < sorted.length ? sorted[k + 1] : null;
        
        // このマークの前（次のマークの後）から、このマークの直前までの範囲を処理
        const rangeStart = nextMark ? nextMark.idx + 1 : group[0] + 1;
        const rangeEnd = currentMark.idx;
        
        if (rangeStart < rangeEnd) {
          processRange(rangeStart, rangeEnd);
        }
        
        // このマークの直後の範囲を処理（最後のマークの場合のみ）
        if (!nextMark) {
          const afterStart = currentMark.idx + 1;
          if (afterStart < endIdx) {
            // レ効果: 直後の1文字を先に読む
            if (currentMark.hasRe && !processed.has(afterStart)) {
              order.push(afterStart);
              processed.add(afterStart);
              // 残りを処理
              if (afterStart + 1 < endIdx) {
                processRange(afterStart + 1, endIdx);
              }
            } else {
              processRange(afterStart, endIdx);
            }
          }
        }
        
        // マーク自体を処理
        if (!processed.has(currentMark.idx)) {
          order.push(currentMark.idx);
          processed.add(currentMark.idx);
        }
      }
    }
    
    // 上中下グループをレ付きで処理（複合パターン用）
    function processPositionGroupWithRe(group, endIdx) {
      // processPositionGroup と同じロジックを使用（レ処理は既に含まれている）
      processPositionGroup(group, endIdx);
    }
    
    // 天地人グループを処理
    function processSkyGroup(group, endIdx) {
      const sorted = group.map(idx => ({
        idx: idx,
        value: parsedChars[idx].parsed.value
      })).sort((a, b) => b.value - a.value);
      
      for (const item of sorted) {
        if (!processed.has(item.idx)) {
          order.push(item.idx);
          processed.add(item.idx);
        }
      }
    }
    
    // 甲乙丙丁グループを処理
    function processKanGroup(group, endIdx) {
      const sorted = group.map(idx => ({
        idx: idx,
        value: parsedChars[idx].parsed.value
      })).sort((a, b) => a.value - b.value);
      
      for (const item of sorted) {
        if (!processed.has(item.idx)) {
          order.push(item.idx);
          processed.add(item.idx);
        }
      }
    }
    
    // メイン処理開始
    processRange(0, parsedChars.length);
    
    return order;
  }
</script>
